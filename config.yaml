# Configuration for CANOE representative period aggregation

# Can switch off plotting if not needed
show_plots: false

# Can use this to do e.g. representative day-pairs (2) or representative weeks (7)
days_per_period: 1 # [integer]

# If this is set to true, representative e.g. weeks will each just be seven representative days in a row
# MUST BE TRUE as some Temoa constraints (e.g. StorageEnergy) implicitly assume time_of_day time slices
# represent slices of a single day. Can set to false if those constraints are edited
disaggregate_multiday: true # [boolean]

# Should we preserve hourly demand values or annual totals in absolute terms?
# The clustering reduces the number of days and renormalises DSDs so can't preserve both
# 'hourly' or 'annual'
demand_preservation: 'hourly' # [str]

# Final number of representative periods to apply to the database
final_periods: 12 # [integer]

# Number of representative days to test and visualise. Should be several
# Only one (selected above) will be applied to the database
test_periods: # [list[integer]]
  #- 4
  #- 8
  #- 12
  #- 16
  #- 32
  #- 64

# Which days to force as cluster centres
# TSAM will perform clustering then recalculate clusters with these new centres,
# moving some days into these clusters instead. 1-index form i.e. D185 -> 185, D007 -> 7
force_days: # [list[integer]]
  - 185

# Configures TSAM autoselection of ectreme periods
# Under each type, add a list of the names of timeseries vectors being clustered over
# which should apply that extreme period selection
extreme_periods: # dict[list[str]]
  max_peak: # day with highest single value
    #- load
    #- net_load
  min_peak: # day with lowest single value
  max_mean: # day with highest mean value
    #- synthetic_net_load_ws
    #- temperature
  min_mean: # day with lowest mean value
    #- temperature

# Additional feature periods to add programatically. Given as a list of dictionaries where
# each dictionary calls a method of feature_identification.py and passes relevant
# parameters. The name of each dictionary does not matter.
custom_features: # list[dict[any]]
  #- method: max_mean_period
  #  days_in_period: 2
  #  timeseries: ontario/net_load

# Translation between 1-indexed days (e.g. D007) and in-timeseries days
# Initially, going from 1-indexing to 0-indexing and omitting Jan 1 so -2
day_to_index: -2 # [integer]

# Which clustering algorithm to use. Default to hierarchical
# averaging, k_means, k_medoids, k_maxoids, hierarchical, adjacent_periods
clustering_method: hierarchical # [string]

# Which timeseries data vectors to cluster over NOTE! COLUMN NAME IN CSV MUST MATCH FILENAME
# Should be a nested dictionary representing directories of all csv timeseries
# files to be clustered over. Final csv files should be in list form. Do not nest
# further dictionaries within final lists.
timeseries: # [dict[dict[...[list[string]]]]]
  ontario: # all are population-weighted
    - cf_hydro # capacity factor of existing hydroelectric (daily and run-of-river)
    - cf_solar # capacity factor of existing solar PV
    - cf_wind # capacity factor of existing onshore wind
    #- cf_new_solar # capacity factor of new solar PV
    #- cf_new_wind # capacity factor of new onshore wind
    #- cloud_cover # percentage cloud cover (fraction covered)
    #- humidity # relative humidity
    #- irradiance_surface # solar irradiance at surface
    #- ldv_charging # demand for electricity for light duty vehicle charging
    - load # historical demand for electricity within the province of Ontario
    #- market_demand # market demand for electricity, including exchange along regional interties
    #- precipitation # precipitation
    #- temperature # temperature
    #- wind_speed # wind speed
    #- net_load
    #- synthetic_net_load_ws # load * (1 - 0.3*cf_new_wind - 0.15*cf_new_solar)

# Example of how the timeseries parameter can be nested
# Note the bottom of the nest always ends in a list (which can be empty)
#timeseries:
#  alberta:
#    - temperature
#    - ldv_charging
#  other:
#    global:
#      - cf_solar
#      - cf_wind
#    economic: